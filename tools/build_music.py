#!/usr/bin/env python

from subprocess import run
from os.path import dirname, basename, realpath, join, exists
from os import chdir, remove
from distutils.spawn import find_executable
from glob import glob
from json import load as json_load

MUSIC_ADDR = 0x8000


class Music:
    def __init__(self, filename, title=None, game=None, artist=None,
                 arrangement=None):
        self.filename = filename
        self.title = title
        self.game = game
        self.artist = artist
        self.arrangement = arrangement
        self.name = self.filename[:self.filename.rfind('.')]
        print(f'Adding music {self.name}...')
        self.asm6 = find_executable('asm6f') or find_executable('asm6')
        self.famistudio = find_executable('famistudio')
        self.music = self.dmc = b''
        self.addr = None
        self.assemble()

    def generate_asm(self):
        print('Generating assembly...')
        run([self.famistudio, f'{self.filename}',  'famistudio-asm-export',
            f'_{self.name}.asm', '-famistudio-asm-format:asm6'])

    def cleanup(self):
        remove('_m.asm')
        remove(f'_{self.name}.bin')
        remove(f'_{self.name}.asm')
        if exists(f'_{self.name}.dmc'):
            remove(f'_{self.name}.dmc')

    def assemble(self):
        self.generate_asm()
        with open('_m.asm', 'w') as f:
            f.write('FAMISTUDIO_DPCM_PTR EQU $00\n')
            f.write(f'.org ${MUSIC_ADDR:X}\n')
            f.write(f'include _{self.name}.asm\n')
        print('Assembling...')
        if run([self.asm6, '-q', '_m.asm', f'_{self.name}.bin']).returncode:
            exit(-1)
        with open(f'_{self.name}.bin', 'rb') as f:
            self.music = f.read()
        if exists(f'_{self.name}.dmc'):
            with open(f'_{self.name}.dmc', 'rb') as f:
                self.dmc = f.read()
        self.cleanup()

    def set_addr(self, addr):
        self.addr = addr

    def music_size(self):
        return len(self.music)

    def dmc_size(self):
        if self.dmc:
            return len(self.dmc)
        return 0

    def total_size(self):
        return len(self.music) + len(self.dmc)

    def music_struct(self):
        return (f"{{ .start = &music_bytes[{self.addr}], "
                f".size = 0x{len(self.music):x} }}")

    def dmc_struct(self):
        if self.dmc:
            return (f"{{ .start = &music_bytes[{self.addr+self.music_size()}], "
                    f".size = 0x{len(self.dmc):x} }}")
        else:
            return "{ .start = NULL, .size = 0 }"

    def attr_struct(self, indent=8):
        return (('{ .title =   %s,\n' + ' ' * (indent+2)
                 + '.game =    %s,\n' + ' ' * (indent+2)
                 + '.artist =  %s,\n' + ' ' * (indent+2)
                 + '.arrange = %s\n' + ' ' * indent + '}')
                % (f'"{self.title.center(28)}"' if self.title else "NULL",
                   f'"{self.game.center(28)}"' if self.game else "NULL",
                   f'"{self.artist.center(28)}"' if self.artist else "NULL",
                   f'"{self.arrangement.center(28)}"' if self.arrangement else "NULL"))

    def __bytes__(self):
        return self.music + (self.dmc or b'')


def create_header(music: list[Music]):
    with open('../../common/credit_music.h', 'w') as h:
        h.write(f'/** This file is generated by {basename(__file__)} */\n\n')
        h.write('#ifndef _CREDIT_MUSIC_H\n')
        h.write('#define _CREDIT_MUSIC_H\n\n')
        h.write('#include <stdint.h>\n')
        h.write('#include <stddef.h>\n')
        h.write('#include "dwr_types.h"\n\n')

        h.write('struct music_data {\n')
        h.write('    const uint8_t *start;\n')
        h.write('    const size_t size;\n')
        h.write('};\n\n')
        h.write('struct music_attr {\n')
        h.write('    const char* title;\n')
        h.write('    const char* game;\n')
        h.write('    const char* artist;\n')
        h.write('    const char* arrange;\n')
        h.write('};\n\n')
        h.write('void add_music(dw_rom* rom, int track);\n')
        h.write('const extern size_t track_count;\n')
        h.write('\n')
        h.write('#endif\n')
        print("Generated header file")


def create_c_file(music: list[Music], music_data):
    with open('../../common/credit_music.c', 'w') as c:
        c.write(f'/** This file is generated by {basename(__file__)} */\n\n')
        c.write('#include <stdint.h>\n')
        c.write('#include <stddef.h>\n')
        c.write('#include "credit_music.h"\n')
        c.write('#include "dwr_types.h"\n')
        c.write('#include "patch.h"\n')
        c.write('#include "expansion.h"\n')
        c.write('\n')
        c.write('static const uint8_t music_bytes[] = {')
        for i, b in enumerate(music_data):
            if i:
                c.write(', ')
            if not i % 12:
                c.write('\n    ')
            c.write(f'0x{b:02x}')
        c.write('\n};\n\n')
        c.write(f'const size_t track_count = {len(music)};\n\n')

        c.write('static void add_attr(dw_rom *rom, int track)\n')
        c.write('{\n')
        c.write('    struct music_attr attr_choice[] = {\n')
        c.write('        ')
        c.write(',\n        '.join([m.attr_struct() for m in music]))
        c.write('\n')
        c.write('    };\n')
        c.write('    const struct music_attr *attr = &attr_choice[track];\n')
        c.write('    uint8_t *ptr = &rom->expansion[CREDIT_MUSIC_ATTRIBUTION - 0xC0000 + 3];\n')
        c.write('    if (attr->title) {\n')
        c.write('        ptr = ppatch(ptr, 14, (const uint8_t*)"  SONG TITLE  ")+3;\n')
        c.write('        ptr = ppatch(ptr, 28, (const uint8_t*)attr->title)+3;\n')
        c.write('        ptr += 31; /* blank line here (for now) */\n')
        c.write('    }\n')
        c.write('    if (attr->game) {\n')
        c.write('        ptr = ppatch(ptr, 14, (const uint8_t*)"     GAME     ")+3;\n')
        c.write('        ptr = ppatch(ptr, 28, (const uint8_t*)attr->game)+3;\n')
        c.write('    }\n')
        c.write('    if (attr->artist) {\n')
        c.write('        ptr = ppatch(ptr, 14, (const uint8_t*)"  COMPOSED BY  ")+3;\n')
        c.write('        ptr = ppatch(ptr, 28, (const uint8_t*)attr->artist)+3;\n')
        c.write('    }\n')
        c.write('    if (attr->arrange) {\n')
        c.write('        ptr = ppatch(ptr, 14, (const uint8_t*)"  ARRANGED BY  ")+3;\n')
        c.write('        ptr = ppatch(ptr, 28, (const uint8_t*)attr->arrange)+3;\n')
        c.write('    }\n')
        c.write('}\n\n')

        c.write('static void add_dpcm(dw_rom *rom, int track) {\n')
        c.write('    struct music_data dmc_choice[] = {\n')
        c.write('        ')
        c.write(',\n        '.join([m.dmc_struct() for m in music]))
        c.write('\n    };\n')
        c.write('    struct music_data *dmc = &dmc_choice[track];\n')
        c.write('    if (dmc->start)\n')
        c.write('        ppatch(&rom->expansion[0x8000], dmc->size, dmc->start);\n')
        c.write('}\n\n')

        c.write('void add_music(dw_rom *rom, int track) {\n')
        c.write('    struct music_data music_choice[] = {\n')
        c.write('        ')
        c.write(',\n        '.join([m.music_struct() for m in music]))
        c.write('\n')
        c.write('    };\n\n')

        c.write('    struct music_data *music = &music_choice[track];\n')
        c.write('    ppatch(&rom->expansion[0x4000], music->size, music->start);\n')
        c.write('    add_dpcm(rom, track);\n')
        c.write('    add_attr(rom, track);\n')
        c.write('}\n\n')

        print("Generated C file")


def check_missing_files(music: list[Music]):
    files_present = [x for x in glob('*.fms')]
    files_configured = [m.filename for m in music]
    for present in files_present:
        if present not in files_configured:
            print(f'{present} exists but is not in the configuration! Ignoring.')


def main():
    chdir(join(dirname(realpath(__file__)), '..', 'expansion', 'music'))
    with open('music.json', 'r') as music_meta:
        music_list = json_load(music_meta)
    music = [Music(**m) for m in music_list]
    check_missing_files(music)
    music_data = b''.join([bytes(m) for m in music])

    addr = 0
    for m in music:
        m.set_addr(addr)
        addr += m.total_size()

    create_c_file(music, music_data)
    create_header(music)


if __name__ == "__main__":
    main()
