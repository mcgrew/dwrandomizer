#!/usr/bin/env python

from subprocess import run
from os.path import dirname, basename, realpath, join, exists
from os import chdir, remove
from distutils.spawn import find_executable
from glob import glob
from json import load as json_load

MUSIC_ADDR = 0x8000
STRING_SIZE = 28


class Music:
    def __init__(self, filename, title=None, game=None, artist=None,
                 artist2=None, artist3=None, artist4=None,
                 arrangement=None):
        self.filename = filename
        self.title = title
        self.game = game
        self.artist = artist
        self.artist2 = artist2
        self.artist3 = artist3
        self.artist4 = artist4
        self.arrangement = arrangement
        self.name = self.filename[:self.filename.rfind('.')]
        print(f'Adding music {self.name}...')
        self.asm6 = find_executable('asm6f') or find_executable('asm6')
        self.famistudio = find_executable('famistudio')
        self.music = self.dmc = b''
        self.addr = None
        self.assemble()

    def generate_asm(self):
        print('Generating assembly...')
        run([self.famistudio, f'{self.filename}',  'famistudio-asm-export',
            f'_{self.name}.asm', '-famistudio-asm-format:asm6'])

    def cleanup(self):
        remove('_m.asm')
        remove(f'_{self.name}.bin')
        remove(f'_{self.name}.asm')
        if exists(f'_{self.name}.dmc'):
            remove(f'_{self.name}.dmc')

    def assemble(self):
        self.generate_asm()
        with open('_m.asm', 'w') as f:
            f.write('FAMISTUDIO_DPCM_PTR EQU $00\n')
            f.write(f'.org ${MUSIC_ADDR:X}\n')
            f.write(f'include _{self.name}.asm\n')
        print('Assembling...')
        if run([self.asm6, '-q', '_m.asm', f'_{self.name}.bin']).returncode:
            exit(-1)
        with open(f'_{self.name}.bin', 'rb') as f:
            self.music = f.read()
        if exists(f'_{self.name}.dmc'):
            with open(f'_{self.name}.dmc', 'rb') as f:
                self.dmc = f.read()
        self.cleanup()

    def set_addr(self, addr):
        self.addr = addr

    def music_size(self):
        return len(self.music)

    def dmc_size(self):
        if self.dmc:
            return len(self.dmc)
        return 0

    def total_size(self):
        return len(self.music) + len(self.dmc)

    def music_struct(self):
        return (f"{{ .start = &music_bytes[{self.addr}], "
                f".size = 0x{len(self.music):x} }}")

    def dmc_struct(self):
        if self.dmc:
            return (f"{{ .start = &music_bytes[{self.addr+self.music_size()}], "
                    f".size = 0x{len(self.dmc):x} }}")
        else:
            return "{ .start = NULL, .size = 0 }"

    def attr_struct(self, indent=8):
        return (('{ .title =   %s,\n' + ' ' * (indent+2)
                 + '.game =    %s,\n' + ' ' * (indent+2)
                 + '.artist =  %s,\n' + ' ' * (indent+2)
                 + '.artist2 =  %s,\n' + ' ' * (indent+2)
                 + '.artist3 =  %s,\n' + ' ' * (indent+2)
                 + '.artist4 =  %s,\n' + ' ' * (indent+2)
                 + '.arrange = %s\n' + ' ' * indent + '}')
                % (f'"{self.title.center(STRING_SIZE)}"' if self.title else "NULL",
                   f'"{self.game.center(STRING_SIZE)}"' if self.game else "NULL",
                   f'"{self.artist.center(STRING_SIZE)}"' if self.artist else "NULL",
                   f'"{self.artist2.center(STRING_SIZE)}"' if self.artist2 else "NULL",
                   f'"{self.artist3.center(STRING_SIZE)}"' if self.artist3 else "NULL",
                   f'"{self.artist4.center(STRING_SIZE)}"' if self.artist4 else "NULL",
                   f'"{self.arrangement.center(STRING_SIZE)}"' if self.arrangement else "NULL"))

    def __bytes__(self):
        return self.music + (self.dmc or b'')


def create_header(music: list[Music]):
    with open('../../common/credit_music.h', 'w') as h:
        h.write(f'/** This file is generated by {basename(__file__)} */\n\n')
        h.write('#ifndef _CREDIT_MUSIC_H\n')
        h.write('#define _CREDIT_MUSIC_H\n\n')
        h.write('#include <stdint.h>\n')
        h.write('#include <stddef.h>\n')
        h.write('#include "dwr_types.h"\n\n')

        h.write('struct music_data {\n')
        h.write('    const uint8_t *start;\n')
        h.write('    const size_t size;\n')
        h.write('};\n\n')
        h.write('struct music_attr {\n')
        h.write('    const char* title;\n')
        h.write('    const char* game;\n')
        h.write('    const char* artist;\n')
        h.write('    const char* artist2;\n')
        h.write('    const char* artist3;\n')
        h.write('    const char* artist4;\n')
        h.write('    const char* arrange;\n')
        h.write('};\n\n')
        h.write('void add_music(dw_rom* rom, int track);\n')
        h.write('const extern size_t track_count;\n')
        h.write('\n')
        h.write('#endif\n')
        print("Generated header file")


def create_c_file(music: list[Music], music_data):
    with open('../../common/credit_music.c', 'w') as c:
        c.write(f'/** This file is generated by {basename(__file__)} */\n\n')
        c.write('#include <stdint.h>\n')
        c.write('#include <stddef.h>\n')
        c.write('#include "credit_music.h"\n')
        c.write('#include "dwr_types.h"\n')
        c.write('#include "patch.h"\n')
        c.write('#include "expansion.h"\n')
        c.write('\n')
        c.write('static const uint8_t music_bytes[] = {')
        for i, b in enumerate(music_data):
            if i:
                c.write(', ')
            if not i % 12:
                c.write('\n    ')
            c.write(f'0x{b:02x}')
        c.write('\n};\n\n')
        c.write(f'const size_t track_count = {len(music)};\n\n')

        c.write('static uint8_t *get_slot(dw_rom *rom, size_t slot) {\n')
        c.write('    const enum subroutine pos[] = {\n')
        for i in range(9):
            c.write(f'        CREDIT_MUSIC_SLOT_{i+1},\n')
        c.write('    };\n')
        c.write('    return (uint8_t*)&rom->expansion[pos[slot]];\n')
        c.write('}\n')
        c.write('\n')

        c.write('static void add_attr(dw_rom *rom, int track)\n')
        c.write('{\n')
        c.write('    struct music_attr attr_choice[] = {\n')
        c.write('        ')
        c.write(',\n        '.join([m.attr_struct() for m in music]))
        c.write('\n')
        c.write('    };\n')
        c.write('    const size_t ppu_color_slot[] = {\n')
        for i in range(3):
            c.write(f'        CREDIT_MUSIC_PPU_{i+1},\n')
        c.write('    };\n')
        c.write('    const struct music_attr *attr = &attr_choice[track];\n')
        c.write('    int slot = 0;\n')
        c.write('\n')
        c.write('    if (attr->title) {\n')
        c.write(f'        ppatch(get_slot(rom, slot), {STRING_SIZE}, (const uint8_t*)attr->title);\n')
        c.write('    }\n')
        c.write('    slot++;\n')
        c.write('    if (attr->game) {\n')
        c.write('        rom->expansion[ppu_color_slot[slot/2]] = 0x0f;\n')
        c.write(f'        ppatch(get_slot(rom, slot++), {STRING_SIZE},\n')
        c.write(f'                (const uint8_t*)"{"GAME".center(STRING_SIZE)}");\n')
        c.write(f'        ppatch(get_slot(rom, slot++), {STRING_SIZE}, (const uint8_t*)attr->game);\n')
        c.write('    }\n')
        c.write('    if (attr->arrange) {\n')
        c.write('        rom->expansion[ppu_color_slot[slot/2]] = 0x0f;\n')
        c.write(f'        ppatch(get_slot(rom, slot++), {STRING_SIZE},\n')
        c.write(f'                (const uint8_t*)"{"ARRANGED BY".center(STRING_SIZE)}");\n')
        c.write(f'        ppatch(get_slot(rom, slot++), {STRING_SIZE}, (const uint8_t*)attr->arrange);\n')
        c.write('    }\n')
        c.write('    if (attr->artist) {\n')
        c.write('        rom->expansion[ppu_color_slot[slot/2]] = 0x0f;\n')
        c.write(f'        ppatch(get_slot(rom, slot++), {STRING_SIZE},\n')
        c.write(f'                (const uint8_t*)"{"COMPOSED BY".center(STRING_SIZE)}");\n')
        c.write(f'        ppatch(get_slot(rom, slot++), {STRING_SIZE}, (const uint8_t*)attr->artist);\n')
        c.write('    }\n')
        c.write('    if (attr->artist2) {\n')
        c.write(f'        ppatch(get_slot(rom, slot++), {STRING_SIZE}, (const uint8_t*)attr->artist2);\n')
        c.write('    }\n')
        c.write('    if (attr->artist3) {\n')
        c.write(f'        ppatch(get_slot(rom, slot++), {STRING_SIZE}, (const uint8_t*)attr->artist3);\n')
        c.write('    }\n')
        c.write('    if (attr->artist4 && slot < 9) {\n')
        c.write(f'        ppatch(get_slot(rom, slot++), {STRING_SIZE}, (const uint8_t*)attr->artist4);\n')
        c.write('    }\n')
        c.write('}\n\n')

        c.write('static void add_dpcm(dw_rom *rom, int track) {\n')
        c.write('    struct music_data dmc_choice[] = {\n')
        c.write('        ')
        c.write(',\n        '.join([m.dmc_struct() for m in music]))
        c.write('\n    };\n')
        c.write('    struct music_data *dmc = &dmc_choice[track];\n')
        c.write('    if (dmc->start)\n')
        c.write('        ppatch(&rom->expansion[0x8000], dmc->size, dmc->start);\n')
        c.write('}\n\n')

        c.write('void add_music(dw_rom *rom, int track) {\n')
        c.write('    struct music_data music_choice[] = {\n')
        c.write('        ')
        c.write(',\n        '.join([m.music_struct() for m in music]))
        c.write('\n')
        c.write('    };\n\n')

        c.write('    struct music_data *music = &music_choice[track];\n')
        c.write('    ppatch(&rom->expansion[0x4000], music->size, music->start);\n')
        c.write('    add_dpcm(rom, track);\n')
        c.write('    add_attr(rom, track);\n')
        c.write('}\n\n')

        print("Generated C file")


def check_missing_files(music: list[Music]):
    files_present = [x for x in glob('*.fms')]
    files_configured = [m.filename for m in music]
    for present in files_present:
        if present not in files_configured:
            print(f'{present} exists but is not in the configuration! Ignoring.')


def main():
    chdir(join(dirname(realpath(__file__)), '..', 'expansion', 'music'))
    with open('music.json', 'r') as music_meta:
        music_list = json_load(music_meta)
    music = [Music(**m) for m in music_list]
    check_missing_files(music)
    music_data = b''.join([bytes(m) for m in music])

    addr = 0
    for m in music:
        m.set_addr(addr)
        addr += m.total_size()

    create_c_file(music, music_data)
    create_header(music)


if __name__ == "__main__":
    main()
